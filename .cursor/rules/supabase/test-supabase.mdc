---
description: Testing procedures for Supabase integration — authentication, database operations, edge functions, realtime subscriptions, and RLS policies
globs: ["**/test/**", "**/tests/**", "**/*.test.ts", "**/*.test.tsx", "supabase/functions/**", "**/hooks/**", "**/integrations/supabase/**"]
alwaysApply: false
---

# Testing Supabase — Frontend Integration

## Overview

Testing procedures for Supabase integration through the StartupAI frontend. Tests verify authentication, database CRUD, edge functions, realtime subscriptions, RLS policy enforcement, and data persistence.

**Testing Tools:**
- Vitest — Unit and integration tests (`npm run test`)
- Browser DevTools — Console monitoring, network debugging
- Supabase MCP — Direct database verification and query testing

**Dev Server:** `http://localhost:8080` (Vite, port 8080)

---

## Frontend Architecture

### Supabase Client

- **File:** `src/integrations/supabase/client.ts`
- **Pattern:** `createClient<Database>(URL, KEY)` with typed schema
- **Import:** `import { supabase } from "@/integrations/supabase/client"`
- **Types:** `src/integrations/supabase/types.ts` — auto-generated `Database` type

### Authentication

- **Provider:** `src/hooks/useAuth.tsx` — exports `AuthProvider` + `useAuth()` hook
- **Protected Routes:** `src/components/auth/ProtectedRoute.tsx` — role-based guards (`requireAdmin`, `requireModerator`)
- **OAuth:** Google and LinkedIn via `signInWithOAuth`
- **Session:** `onAuthStateChange` listener, localStorage persistence, auto-refresh
- **Dev bypass:** `DEV_BYPASS_AUTH` flag in useAuth

### Data Fetching

- **Pattern:** React Query (TanStack Query) + direct Supabase queries
- **No service layer** — hooks call `supabase.from()` directly
- **Key hooks:**
  - `src/hooks/useAuth.tsx` — Auth, profiles, user roles
  - `src/hooks/useTasks.ts` — Task CRUD
  - `src/hooks/useProjects.ts` — Projects
  - `src/hooks/useCRM.ts` — Contacts, deals
  - `src/hooks/useDocuments.ts` — Document storage
  - `src/hooks/useEvents.ts` — Events
  - `src/hooks/useInvestors.ts` — Investor database
  - `src/hooks/useLeanCanvas.ts` — Lean canvas
  - `src/hooks/useValidatorPipeline.ts` — Validator pipeline orchestration
  - `src/hooks/useValidationReport.ts` — Report fetching
  - `src/hooks/useDashboardData.ts` — Dashboard metrics
  - `src/hooks/useNotifications.ts` — Notifications
  - `src/hooks/useSettings.ts` — User preferences
  - `src/hooks/useAIUsageLimits.ts` — AI quota tracking
  - `src/hooks/useAIChat.ts` — AI chat messages

### Edge Function Calls

- **Helper:** `src/lib/invokeAgent.ts` — universal `invokeAgent<T>()` wrapper
- **Pattern:** `supabase.functions.invoke(functionName, { body, headers })`
- **Auth:** Bearer token from `supabase.auth.getSession()`
- **Specialized invokers:** `invokeOnboardingAgent()`, `invokeCanvasAgent()`, `invokePitchAgent()`, etc.

### Realtime Subscriptions

- **Base hook:** `src/hooks/realtime/useRealtimeChannel.ts`
- **Pattern:** Broadcast with private channels + `setAuth()` before subscribing
- **Specialized hooks:**
  - `useRealtimeAIChat.ts` — AI chat streaming
  - `useCanvasRealtime.ts` — Canvas collaboration
  - `usePitchDeckRealtime.ts` — Pitch deck sync
  - `useCRMRealtime.ts` — CRM changes
  - `useDocumentsRealtime.ts` — Document updates
  - `useEventsRealtime.ts` — Event changes
  - `useInvestorsRealtime.ts` — Investor updates
  - `useOnboardingRealtime.ts` — Onboarding sync

### Context & Providers

- `src/contexts/CoachSyncContext.tsx` — Validator panel synchronization
- `src/providers/AIAssistantProvider.tsx` — Global AI assistant state
- `src/providers/PlaybookProvider.tsx` — Playbook/strategy state

### Provider Hierarchy (App.tsx)

```
QueryClientProvider
  └─ AuthProvider
       └─ TooltipProvider
            └─ BrowserRouter
                 └─ AIAssistantProvider
                      └─ PlaybookProvider
                           └─ Routes
```

---

## Test Phases

### Phase 1: Authentication Flow

**Entry point:** `src/hooks/useAuth.tsx` → `AuthProvider`

**Test Scenarios:**

1. **Google OAuth Login**
   - Navigate to `/login`
   - Click Google sign-in
   - Verify: `signInWithOAuth({ provider: 'google' })` called
   - Network: POST to `/auth/v1/token` succeeds (200)
   - Verify: User object set in AuthContext, profile fetched from `profiles` table

2. **Session Persistence**
   - Login, then refresh page
   - Verify: `onAuthStateChange` fires `SIGNED_IN` event
   - Verify: Session restored from localStorage
   - Console: No auth errors

3. **Protected Route Guard**
   - Navigate to `/dashboard` without auth
   - Verify: `ProtectedRoute` redirects to `/login`
   - Login, navigate to `/dashboard`
   - Verify: Page renders with user data

4. **Logout**
   - Call `signOut()` from `useAuth()`
   - Verify: Session cleared, user set to null
   - Verify: Redirect to home page

**Verification Checklist:**
- [ ] Google OAuth flow completes
- [ ] Session persists across page refresh
- [ ] Protected routes redirect unauthenticated users
- [ ] Logout clears session correctly
- [ ] Console: No auth errors
- [ ] Network: `/auth/v1/token` returns 200

---

### Phase 2: Data CRUD Operations (React Query + Supabase)

**Pattern:** All hooks use React Query for caching/mutations + direct `supabase.from()` calls.

#### Profile & Startup

**Hook:** `useAuth.tsx` (profile), startup hooks

- Navigate to `/profile`
- Verify: `supabase.from('profiles').select()` returns user profile
- Edit profile fields, save
- Verify: PATCH request to `/rest/v1/profiles` succeeds (200/204)
- Refresh page — changes persisted

#### Tasks

**Hook:** `src/hooks/useTasks.ts`

- Navigate to `/tasks`
- Verify: `supabase.from('tasks').select('*, project:projects(id, name)')` loads
- Create task: POST to `/rest/v1/tasks` (201)
- Update task status: PATCH to `/rest/v1/tasks` (200/204)
- Delete task: DELETE to `/rest/v1/tasks` (200/204)
- Verify: React Query cache invalidation triggers refetch

#### CRM

**Hook:** `src/hooks/useCRM.ts`

- Navigate to `/crm`
- Verify: Contacts and deals load from `contacts`, `deals` tables
- Create contact → POST succeeds
- Create deal → POST succeeds
- Update deal stage → PATCH succeeds

#### Dashboard Metrics

**Hook:** `src/hooks/useDashboardData.ts`

- Navigate to `/dashboard`
- Verify: Metrics load from `metric_snapshots` or `startup_metrics_snapshots`
- Verify: Charts render with data
- Verify: Activity feed loads from `activities` table

**Verification Checklist:**
- [ ] All CRUD hooks return data (no RLS errors)
- [ ] Mutations invalidate React Query cache
- [ ] Network: All REST requests return 200/201/204
- [ ] Console: No Supabase errors
- [ ] Data persists across page refresh

---

### Phase 3: Edge Function Calls

**Helper:** `src/lib/invokeAgent.ts`

**Test Scenarios:**

1. **Validator Pipeline**
   - Hook: `useValidatorPipeline.ts`
   - Navigate to `/validator`, enter startup description
   - Verify: `supabase.functions.invoke('validator-start', { body })` called
   - Network: POST `/functions/v1/validator-start` returns 200
   - Verify: Pipeline starts, progress updates received via realtime

2. **Validator Follow-up**
   - Hook: `useValidatorFollowup.ts`
   - During chat interview, send follow-up
   - Verify: `supabase.functions.invoke('validator-followup')` called
   - Network: POST `/functions/v1/validator-followup` returns 200

3. **AI Chat**
   - Hook: `useAIChat.ts`
   - Navigate to AI chat, send message
   - Verify: `supabase.functions.invoke('ai-chat')` called
   - Network: POST `/functions/v1/ai-chat` returns 200

4. **Onboarding Agent**
   - Hook: `src/hooks/onboarding/invokeAgent.ts`
   - Start onboarding wizard
   - Verify: `supabase.functions.invoke('onboarding-agent')` called

5. **Pitch Deck Agent**
   - Invoker: `invokePitchAgent()`
   - Generate pitch deck from wizard
   - Verify: `supabase.functions.invoke('pitch-deck-agent')` called
   - Network: POST `/functions/v1/pitch-deck-agent` returns 200

6. **Image Generation**
   - Navigate to pitch deck, click generate image
   - Verify: `supabase.functions.invoke('generate-image')` called
   - Network: POST `/functions/v1/generate-image` returns 200

**All 40 Edge Functions (JWT status):**

| Function | JWT | Primary Hook/Invoker |
|----------|:---:|---------------------|
| `validator-start` | Yes | `useValidatorPipeline.ts` |
| `validator-followup` | Yes | `useValidatorFollowup.ts` |
| `validator-status` | Yes | `useValidatorPipeline.ts` |
| `validator-regenerate` | Yes | `useValidatorRegenerate.ts` |
| `validator-panel-detail` | Yes | Report panel components |
| `ai-chat` | Yes | `useAIChat.ts` |
| `onboarding-agent` | Yes | `onboarding/invokeAgent.ts` |
| `lean-canvas-agent` | Yes | `invokeCanvasAgent()` |
| `pitch-deck-agent` | Yes | `invokePitchAgent()` |
| `crm-agent` | Yes | `invokeCRMAgent()` |
| `documents-agent` | Yes | `invokeAgent('documents-agent')` |
| `event-agent` | Yes | `invokeAgent('event-agent')` |
| `investor-agent` | Yes | `invokeInvestorAgent()` |
| `task-agent` | Yes | `invokeTaskAgent()` |
| `insights-generator` | Yes | Dashboard components |
| `industry-expert-agent` | Yes | `invokeIndustryExpert()` |
| `action-recommender` | Yes | Dashboard components |
| `health-scorer` | Yes | Dashboard components |
| `dashboard-metrics` | Yes | Cron + manual trigger |
| `stage-analyzer` | Yes | Dashboard components |
| `workflow-trigger` | Yes | Automation engine |
| `prompt-pack` | Yes | Prompt pack UI |
| `load-knowledge` | Yes | Knowledge management |
| `knowledge-search` | Yes | Knowledge search UI |
| `knowledge-ingest` | Yes | Document ingestion |
| `profile-import` | Yes | Profile import flow |
| `canvas-coach` | Yes | Canvas coaching |
| `market-research` | Yes | Market research page |
| `experiment-agent` | Yes | Experiment tracking |
| `opportunity-canvas` | Yes | Opportunity canvas |
| `compute-daily-focus` | Yes | Cron job |
| `sprint-agent` | Yes | Sprint board |
| `weekly-review` | Yes | Cron job |
| `whatsapp-agent` | Yes | WhatsApp integration |
| `chatbot-agent` | Yes | Public chatbot |
| `generate-image` | Yes | Image generation |
| `auth-check` | Yes | Auth verification |
| `health` | No | Health check endpoint |
| `stripe-webhook` | No | Stripe signature verification |
| `share-meta` | No | Public OG meta tags |

**Verification Checklist:**
- [ ] All edge function calls include Bearer token
- [ ] Network: POST `/functions/v1/*` returns 200
- [ ] Console: No function invocation errors
- [ ] Timeout handling works (Promise.race pattern)
- [ ] Error responses display user-friendly messages

---

### Phase 4: Realtime Subscriptions

**Base hook:** `src/hooks/realtime/useRealtimeChannel.ts`

**Test Scenarios:**

1. **Channel Setup**
   - Load a page with realtime (e.g., `/validator`)
   - Verify: `supabase.channel(topic, { config: { private: true } })` called
   - Verify: `supabase.realtime.setAuth()` called before subscribe
   - Console: Channel enters `SUBSCRIBED` state

2. **Broadcast Event Reception**
   - Open app in two tabs
   - Update data in tab A (e.g., create a task)
   - Verify: Tab B receives broadcast event and updates UI
   - Console: `[Realtime] <topic> received <event>:` log entry

3. **Connection Quality (RT-7)**
   - Monitor `useRealtimeChannel` metrics
   - Verify: `connectedAt`, `reconnectCount`, `lastMessageAt` tracked

4. **Cleanup on Unmount**
   - Navigate away from realtime page
   - Verify: `supabase.removeChannel()` called
   - Console: No lingering subscriptions

**Realtime Usage Pattern:**
```typescript
const { isSubscribed } = useRealtimeChannel({
  topic: `tasks:${startupId}:changes`,
  onBroadcast: {
    INSERT: (payload) => addTask(payload.new),
    UPDATE: (payload) => updateTask(payload.new),
    DELETE: (payload) => removeTask(payload.old),
  },
  enabled: !!startupId,
});
```

**Verification Checklist:**
- [ ] Channels subscribe successfully (SUBSCRIBED state)
- [ ] `setAuth()` called before subscription
- [ ] Broadcast events received and handled
- [ ] UI updates automatically on remote changes
- [ ] Channels cleaned up on component unmount
- [ ] No duplicate subscriptions

---

### Phase 5: RLS Policy Verification

**Test Scenarios:**

1. **Multi-Tenant Isolation**
   - Login as User A (org X)
   - Query: `supabase.from('startups').select()` returns only org X startups
   - Attempt to read org Y data → empty result (RLS blocks)

2. **Own Data Access**
   - Login as User A
   - Verify: Profile, tasks, projects for own org load correctly
   - Verify: `user_org_id()` helper resolves correctly in RLS policies

3. **Role-Based Access**
   - Admin user: Can manage roles via `user_roles` table
   - Regular user: Can only view own roles
   - Verify: `ProtectedRoute` with `requireAdmin` blocks non-admin users

**Key RLS Helpers (verified in migrations):**
- `user_org_id()` — Returns current user's `org_id` from `profiles`
- `startup_in_org(startup_id)` — Checks if startup belongs to user's org

**Verification Checklist:**
- [ ] Users only see data from their own organization
- [ ] Cross-org data access returns empty (not 403)
- [ ] Admin-only operations blocked for regular users
- [ ] Network: No RLS error codes in responses

---

### Phase 6: Error Handling

**Test Scenarios:**

1. **Network Errors**
   - Disconnect network, attempt save
   - Verify: Error toast/message displayed
   - Verify: Data not lost (React Query cache intact)

2. **Edge Function Timeout**
   - Trigger long-running function (e.g., `validator-start`)
   - Verify: `Promise.race` timeout fires before 300s wall-clock
   - Verify: User sees timeout message, not hang

3. **Auth Token Expiry**
   - Let session expire
   - Verify: `autoRefreshToken` handles refresh
   - Verify: If refresh fails, redirect to login

4. **Invalid Operations**
   - Attempt duplicate insert (unique constraint)
   - Verify: Error caught, user-friendly message shown
   - Console: Error logged with details

**Verification Checklist:**
- [ ] Network errors show user-friendly messages
- [ ] Edge function timeouts handled gracefully
- [ ] Auth token refresh works automatically
- [ ] Duplicate/constraint errors handled
- [ ] Console errors logged for debugging

---

### Phase 7: Performance

**Test Scenarios:**

1. **Page Load**
   - Navigate to `/dashboard`
   - Target: Page interactive in < 3 seconds
   - Verify: React Query prefetching works

2. **Data Loading**
   - Load pages with large datasets (CRM, tasks)
   - Verify: Pagination or virtualization prevents slowdown
   - Network: Individual requests < 2 seconds

3. **Realtime Performance**
   - Receive rapid broadcast updates
   - Verify: UI remains responsive (no jank)
   - Verify: React Query batch updates

**Verification Checklist:**
- [ ] Page load < 3 seconds
- [ ] Data requests < 2 seconds
- [ ] UI responsive during realtime updates
- [ ] No unnecessary re-renders (React DevTools)

---

## End-to-End Happy Path

```
1. Auth
   → Navigate to http://localhost:8080
   → Login via Google OAuth
   → Verify: Dashboard loads with user data

2. Profile
   → Navigate to /profile
   → Edit startup name, save
   → Verify: PATCH /rest/v1/profiles or /rest/v1/startups succeeds

3. Validator Pipeline
   → Navigate to /validator
   → Enter startup description, submit
   → Verify: validator-start invoked, pipeline runs
   → Wait for report generation
   → Verify: Report renders with scores and verdicts

4. CRM
   → Navigate to /crm
   → Create contact and deal
   → Verify: POST operations succeed

5. Tasks
   → Navigate to /tasks
   → Create task, update status
   → Verify: React Query cache updates

6. Dashboard
   → Navigate to /dashboard
   → Verify: Metrics, insights, activity feed load

7. Persistence
   → Refresh page
   → Verify: All data intact

8. Final Check
   → Console: 0 errors
   → Network: 0 failed requests (4xx/5xx)
```

---

## Quick Test Checklist

### Authentication
- [ ] Google OAuth login works
- [ ] Session persists across refresh
- [ ] Protected routes enforce auth
- [ ] Logout clears session
- [ ] Console: No auth errors

### Data Operations
- [ ] Profile CRUD works
- [ ] Tasks CRUD works
- [ ] CRM CRUD works
- [ ] Dashboard loads metrics
- [ ] React Query caching works
- [ ] Network: All requests succeed

### Edge Functions
- [ ] `validator-start` pipeline runs
- [ ] `ai-chat` responds
- [ ] `pitch-deck-agent` generates deck
- [ ] All calls include Bearer token
- [ ] Timeout handling works

### Realtime
- [ ] Channels subscribe (SUBSCRIBED state)
- [ ] Broadcast events sync across tabs
- [ ] Cleanup on component unmount
- [ ] No duplicate subscriptions

### RLS
- [ ] Multi-tenant isolation works
- [ ] Own org data accessible
- [ ] Cross-org data blocked

### Error Handling
- [ ] Network errors handled gracefully
- [ ] Auth refresh works
- [ ] Console errors logged

### Performance
- [ ] Page load < 3 seconds
- [ ] No request > 2 seconds
- [ ] UI responsive

---

## Debugging Tips

### Common Issues

1. **Auth Not Working**
   - Check: `src/integrations/supabase/client.ts` — URL and key configured
   - Check: `src/hooks/useAuth.tsx` — `onAuthStateChange` firing
   - Console: Look for `SIGNED_IN` / `SIGNED_OUT` events
   - Network: Check `/auth/v1/token` request status

2. **Data Not Loading**
   - Check: RLS policies allow access for user's `org_id`
   - Check: React Query `queryKey` is correct
   - Console: Look for `relation "X" does not exist` or RLS errors
   - Network: Check `/rest/v1/*` request status codes

3. **Edge Functions Failing**
   - Check: Bearer token included in request headers
   - Check: Function name matches deployed function (see table above)
   - Console: Look for `FunctionsHttpError` or `FunctionsFetchError`
   - Network: Check `/functions/v1/*` response status and body

4. **Realtime Not Working**
   - Check: `private: true` set on channel config
   - Check: `setAuth()` called before `.subscribe()`
   - Check: RLS policies on `realtime.messages` allow user access
   - Console: Look for channel state changes (SUBSCRIBED, CHANNEL_ERROR)
   - Network: Check WebSocket connection in Network tab

5. **React Query Issues**
   - Check: `queryKey` uniqueness (include IDs)
   - Check: `enabled` flag prevents queries without required data
   - DevTools: Use React Query DevTools to inspect cache

---

## Success Criteria

- All authentication flows work correctly
- All database CRUD operations succeed via hooks
- All edge function calls return 200
- Realtime subscriptions connect and sync
- RLS policies enforce multi-tenant isolation
- Data persists across page refresh
- Error handling provides user-friendly feedback
- Performance meets targets (< 3s load, < 2s requests)
- **Zero console errors**
- **Zero network failures (4xx/5xx)**
