import { LeanCanvasData, CANVAS_BOX_CONFIG } from '@/hooks/useLeanCanvas';

// Export canvas as PNG using html2canvas
export async function exportCanvasAsPng(
  elementId: string,
  filename: string = 'lean-canvas'
): Promise<void> {
  const element = document.getElementById(elementId);
  if (!element) {
    throw new Error('Canvas element not found');
  }

  // Dynamic import to reduce bundle size
  const html2canvas = (await import('html2canvas')).default;

  const canvas = await html2canvas(element, {
    backgroundColor: '#ffffff',
    scale: 2, // Higher resolution
    logging: false,
    useCORS: true,
  });

  const link = document.createElement('a');
  link.download = `${filename}-${new Date().toISOString().split('T')[0]}.png`;
  link.href = canvas.toDataURL('image/png');
  link.click();
}

// Export canvas as PDF
export async function exportCanvasAsPdf(
  canvasData: LeanCanvasData,
  companyName: string = 'My Startup',
  filename: string = 'lean-canvas'
): Promise<void> {
  // Dynamic import to reduce bundle size
  const { jsPDF } = await import('jspdf');

  const doc = new jsPDF({
    orientation: 'landscape',
    unit: 'mm',
    format: 'a4',
  });

  const pageWidth = doc.internal.pageSize.getWidth();
  const pageHeight = doc.internal.pageSize.getHeight();
  const margin = 10;
  const contentWidth = pageWidth - 2 * margin;
  const contentHeight = pageHeight - 2 * margin - 20; // Reserve space for header

  // Header
  doc.setFontSize(18);
  doc.setFont('helvetica', 'bold');
  doc.text(`${companyName} - Lean Canvas`, margin, margin + 8);

  doc.setFontSize(10);
  doc.setFont('helvetica', 'normal');
  doc.setTextColor(128, 128, 128);
  doc.text(new Date().toLocaleDateString('en-US', { 
    year: 'numeric', 
    month: 'long', 
    day: 'numeric' 
  }), pageWidth - margin, margin + 8, { align: 'right' });

  doc.setTextColor(0, 0, 0);

  // Grid layout configuration
  const startY = margin + 15;
  const row1Height = contentHeight * 0.45;
  const row2Height = contentHeight * 0.25;
  const row3Height = contentHeight * 0.25;
  const col5Width = contentWidth / 5;
  const col2Width = contentWidth / 2;

  // Box positions
  const boxes = [
    // Row 1: 5 columns
    { key: 'problem', x: margin, y: startY, w: col5Width, h: row1Height },
    { key: 'solution', x: margin + col5Width, y: startY, w: col5Width, h: row1Height },
    { key: 'uniqueValueProp', x: margin + col5Width * 2, y: startY, w: col5Width, h: row1Height },
    { key: 'unfairAdvantage', x: margin + col5Width * 3, y: startY, w: col5Width, h: row1Height },
    { key: 'customerSegments', x: margin + col5Width * 4, y: startY, w: col5Width, h: row1Height },
    // Row 2: 2 columns (under Problem and Solution)
    { key: 'keyMetrics', x: margin, y: startY + row1Height, w: col5Width, h: row2Height },
    { key: 'channels', x: margin + col5Width, y: startY + row1Height, w: col5Width, h: row2Height },
    // Row 3: 2 wide columns
    { key: 'costStructure', x: margin, y: startY + row1Height + row2Height, w: col2Width, h: row3Height },
    { key: 'revenueStreams', x: margin + col2Width, y: startY + row1Height + row2Height, w: col2Width, h: row3Height },
  ];

  const boxConfig = CANVAS_BOX_CONFIG.reduce((acc, box) => {
    acc[box.key] = box;
    return acc;
  }, {} as Record<string, typeof CANVAS_BOX_CONFIG[0]>);

  // Draw boxes
  boxes.forEach(({ key, x, y, w, h }) => {
    const config = boxConfig[key];
    const data = canvasData[key as keyof LeanCanvasData];
    const items = data?.items || [];

    // Box border
    doc.setDrawColor(200, 200, 200);
    doc.setLineWidth(0.3);
    doc.rect(x, y, w, h);

    // Title background
    doc.setFillColor(245, 245, 245);
    doc.rect(x, y, w, 8, 'F');

    // Title
    doc.setFontSize(9);
    doc.setFont('helvetica', 'bold');
    doc.text(config?.title || key, x + 2, y + 5.5);

    // Items
    doc.setFontSize(8);
    doc.setFont('helvetica', 'normal');
    
    let itemY = y + 12;
    const maxItems = Math.floor((h - 12) / 5);
    
    items.slice(0, maxItems).forEach((item) => {
      const lines = doc.splitTextToSize(`â€¢ ${item}`, w - 4);
      lines.forEach((line: string) => {
        if (itemY < y + h - 2) {
          doc.text(line, x + 2, itemY);
          itemY += 4;
        }
      });
    });

    if (items.length > maxItems) {
      doc.setTextColor(128, 128, 128);
      doc.text(`+${items.length - maxItems} more...`, x + 2, y + h - 3);
      doc.setTextColor(0, 0, 0);
    }
  });

  // Footer
  doc.setFontSize(8);
  doc.setTextColor(128, 128, 128);
  doc.text('Generated by StartupAI', margin, pageHeight - 5);

  doc.save(`${filename}-${new Date().toISOString().split('T')[0]}.pdf`);
}

// Check if export libraries are available
export function checkExportSupport(): { png: boolean; pdf: boolean } {
  return {
    png: true, // html2canvas is dynamically imported
    pdf: true, // jspdf is dynamically imported
  };
}
